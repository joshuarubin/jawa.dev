<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Interface Pitfalls and Harnessing `io.Reader` | Joshua Rubin</title><style>html{font-size:62.5%}body,form.formspree input[type=email],form.formspree input[type=text],form.formspree input[type=submit],form.formspree textarea{background:#232c31;color:#c5c8c6;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol;font-size:1.6rem;line-height:1.6}body{margin:4rem auto;max-width:90rem;padding:0 1rem;-webkit-text-size-adjust:100%}h1,h2,h3{line-height:1.2;margin:0;padding:0}.list .description{margin-bottom:2.4rem}.header{border-bottom:.1rem solid;font-size:1.8rem;font-weight:400;margin-bottom:2.4rem;padding-bottom:.8rem;padding-top:0}.header-menu{float:right}ul.pagination{list-style-type:none;padding:0;text-align:center}ul.pagination>li{display:inline-block;padding:0 .8rem}.footer{border-top:.1rem solid;margin-top:2.4rem;padding-bottom:0;padding-top:.8rem;text-align:center}img{display:block;margin-left:auto;margin-right:auto;max-height:100%;max-width:100%}tt,code,kbd,samp,xmp,pre,plaintext,listing{font-family:sf mono,Consolas,liberation mono,Menlo,Courier,monospace;font-size:87.5%;line-height:1.3;margin:.5rem 0}pre code{font-size:inherit}a{color:#81a2be;text-decoration:none}a:hover{text-decoration:underline}code,.categories,.tags{background-color:#425059;border-radius:.3rem;padding:.28rem .56rem}a.categories:hover,a.tags:hover{text-decoration:none}::selection{background-color:#f0c674;color:#232c31}time,.reading-time{color:#425059}article{margin:0;padding:0}header{margin-bottom:2.4rem;padding-bottom:.8rem;padding-top:0}form.formspree input[type=email],form.formspree input[type=text],form.formspree input[type=submit],form.formspree textarea{-webkit-appearance:none;border:.1rem solid #425059;border-radius:0;box-sizing:border-box;display:block;margin:.5rem 0;max-width:100%;padding:0 .8rem}form.formspree input[type=email],form.formspree input[type=text]{width:30rem}form.formspree textarea{height:20rem;width:100%}hr{border:0;border-top:.1rem solid #425059;margin:2rem auto;width:25%}::placeholder{color:#425059}.tags,.categories{display:inline-block}.post-meta{margin-top:.3rem}.chroma{background-color:#232c31;border:.1rem solid #425059;color:#c5c8c6}.chroma .chroma{border:none}.chroma code{background-color:inherit;padding:inherit}.chroma .err{background-color:#c66;color:#232c31}.chroma .lntd{border:0;margin:0;padding:0;vertical-align:top}.chroma .lntable{border:0;border-spacing:0;display:block;margin:0;overflow:auto;padding:0;width:auto}.chroma .hl{background-color:#425059;display:block;width:100%}.chroma .lnt{color:#425059;margin-right:.56rem;padding:0 .56rem}.chroma .ln{color:#425059;margin-right:.56rem;padding:0 .56rem}.chroma .hl .lnt,.chroma .hl .ln{color:#c5c8c6}.chroma .k{color:#81a2be}.chroma .kc{color:#c66}.chroma .kd{color:#81a2be}.chroma .kn{color:#81a2be}.chroma .kp{color:#6c7a80}.chroma .kr{}.chroma .kt{color:#c66}.chroma .n{color:#81a2be}.chroma .na{}.chroma .nb{color:#b294bb}.chroma .nc{color:#f0c674}.chroma .no{}.chroma .nd{}.chroma .ne{}.chroma .nf{color:#f0c674}.chroma .nn{color:#f0c674}.chroma .nt{}.chroma .nv{}.chroma .s{color:#b5bd68}.chroma .sa{color:#b5bd68}.chroma .sb{color:#b5bd68}.chroma .sc{color:#b5bd68}.chroma .dl{color:#b5bd68}.chroma .sd{color:#b5bd68}.chroma .s2{color:#b5bd68}.chroma .se{color:#b5bd68}.chroma .sh{color:#b5bd68}.chroma .si{color:#b5bd68}.chroma .sx{}.chroma .sr{color:#b5bd68}.chroma .s1{color:#b5bd68}.chroma .ss{color:#b5bd68}.chroma .m{color:#c66}.chroma .mb{color:#c66}.chroma .mf{color:#c66}.chroma .mh{color:#c66}.chroma .mi{color:#c66}.chroma .il{color:#c66}.chroma .mo{color:#c66}.chroma .ow{}.chroma .c{color:#6c7a80;font-style:italic}.chroma .ch{color:#6c7a80;font-style:italic}.chroma .cm{color:#6c7a80;font-style:italic}.chroma .c1{color:#6c7a80;font-style:italic}.chroma .cs{}.chroma .cp{}.chroma .cpf{}.chroma .gd{}.chroma .ge{font-style:italic}.chroma .gr{}.chroma .gh{}.chroma .gi{}.chroma .go{}.chroma .gp{}.chroma .gs{}.chroma .gu{}.chroma .gt{}.chroma .gl{}.chroma .w{}</style><meta property="og:title" content="Interface Pitfalls and Harnessing `io.Reader`"><meta property="og:description" content="What makes Go's interfaces great, why io.Reader is amazing and implement a new io.Reader
"><meta property="og:type" content="article"><meta property="og:url" content="https://jawa.dev/posts/2016/10/interface-pitfalls-and-harnessing-io.reader/"><meta property="og:image" content="https://jawa.dev/img/caddyshack.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-10-20T00:00:00-07:00"><meta property="article:modified_time" content="2019-02-15T14:12:58-07:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jawa.dev/img/caddyshack.jpg"><meta name=twitter:title content="Interface Pitfalls and Harnessing `io.Reader`"><meta name=twitter:description content="What makes Go's interfaces great, why io.Reader is amazing and implement a new io.Reader
"><link rel=canonical href=https://jrub.in/golang-interface-pitfalls-and-io-reader-a57e2d8842a2><link rel=apple-touch-icon-precomposed sizes=57x57 href=https://jawa.dev/img/apple-touch-icon-57x57.png><link rel=apple-touch-icon-precomposed sizes=114x114 href=https://jawa.dev/img/apple-touch-icon-114x114.png><link rel=apple-touch-icon-precomposed sizes=72x72 href=https://jawa.dev/img/apple-touch-icon-72x72.png><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://jawa.dev/img/apple-touch-icon-144x144.png><link rel=apple-touch-icon-precomposed sizes=60x60 href=https://jawa.dev/img/apple-touch-icon-60x60.png><link rel=apple-touch-icon-precomposed sizes=120x120 href=https://jawa.dev/img/apple-touch-icon-120x120.png><link rel=apple-touch-icon-precomposed sizes=76x76 href=https://jawa.dev/img/apple-touch-icon-76x76.png><link rel=apple-touch-icon-precomposed sizes=152x152 href=https://jawa.dev/img/apple-touch-icon-152x152.png><link rel=icon type=image/png href=https://jawa.dev/img/favicon-196x196.png sizes=196x196><link rel=icon type=image/png href=https://jawa.dev/img/favicon-96x96.png sizes=96x96><link rel=icon type=image/png href=https://jawa.dev/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://jawa.dev/img/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=https://jawa.dev/img/favicon-128.png sizes=128x128><meta name=application-name content="Joshua Rubin"><meta name=msapplication-TileColor content="#FFFFFF"><meta name=msapplication-TileImage content="/img/mstile-144x144.png"><meta name=msapplication-square70x70logo content="/img/mstile-70x70.png"><meta name=msapplication-square150x150logo content="/img/mstile-150x150.png"><meta name=msapplication-wide310x150logo content="/img/mstile-310x150.png"><meta name=msapplication-square310x310logo content="/img/mstile-310x310.png"></head><body><div class=header><a href=https://jawa.dev/>home</a><div class=header-menu><a href=https://jawa.dev/about/>about</a>
<a href=https://jawa.dev/contact/>contact</a></div></div><div id=content><main aria-role=main><header><h1>Interface Pitfalls and Harnessing <code>io.Reader</code></h1><div class=post-meta><sup><time datetime=2016-10-20>Oct 20, 2016</time>
<span class=reading-time>12 min read</span>
<a class=categories href=https://jawa.dev/categories/programming/>programming</a>
<a class=tags href=https://jawa.dev/tags/go/>go</a></sup></div></header><article><p>When Go was first announced I remember looking over the list of its key
features and feeling astonished that a new language would omit the classes and
inheritance that I had come to depend on so heavily. My interest faded quickly.</p><p>Fast forward a few years and our team has fully embraced Go for its speed,
tooling, standard library, concurrency support and all the other things we know
and love about Go. If you&rsquo;re interested in learning more about how we use Go at
zvelo, we&rsquo;ve recently <a href=https://zvelo.com/zvelo-on-the-go/>published a blog post</a>.</p><p>The concept of interfaces, while certainly not new to us, seemed more like an
afterthought in our embrace of the language. We had used interfaces in C++, and
they were useful but tedious. Despite hearing so many great things about
implicitly satisfied interfaces, it still took us quite a while to really
internalize what the implications of this simple concept were.</p><p>Let&rsquo;s walk through the process that a newcomer to Go might follow in developing
a simple text processor that replaces instances of <em>&ldquo;hodor&rdquo;</em> with <em>&ldquo;hold the door&rdquo;</em>.
We will start with a naïve implementation and refactor it over several steps.</p><hr><h2 id=naïve-implementation>Naïve Implementation</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>process</span><span class=p>(</span><span class=nx>text</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
	<span class=k>return</span> <span class=nx>regexp</span><span class=p>.</span><span class=nf>MustCompile</span><span class=p>(</span><span class=s>`hodor`</span><span class=p>).</span>
		<span class=nf>ReplaceAllString</span><span class=p>(</span><span class=nx>text</span><span class=p>,</span> <span class=s>`hold the door`</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>string length: 130B
BenchmarkNaive-8  200000  13003 ns/op  41985 B/op  45 allocs/op

string length: 130000B
BenchmarkNaive-8  200  6584315 ns/op  1494456 B/op  10063 allocs/op
</code></pre></td></tr></table></div></div><p>Let&rsquo;s ignore for the duration of the exercise the simplicity of the
function — it simply represents anything that has to modify data. There are
several obvious problems. First of all, the most glaring issue is that the
regular expression is being compiled every time <em>process</em> is executed.
Additionally, while there is no risk here (since the regex is fine), if the
regular expression were to fail compilation (if, say, it was loaded
dynamically), it would cause the application to panic during runtime. This would
be unacceptable for production systems, and proper error handling should have
been used instead (with <code>regexp.Compile</code>), but I digress.</p><hr><h2 id=precompiled-regular-expressions>Precompiled Regular Expressions</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>re</span> <span class=p>=</span> <span class=nx>regexp</span><span class=p>.</span><span class=nf>MustCompile</span><span class=p>(</span><span class=s>`hodor`</span><span class=p>)</span>

<span class=kd>func</span> <span class=nf>process</span><span class=p>(</span><span class=nx>text</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
	<span class=k>return</span> <span class=nx>re</span><span class=p>.</span><span class=nf>ReplaceAllString</span><span class=p>(</span><span class=nx>text</span><span class=p>,</span> <span class=s>`hold the door`</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>We keep using <code>regexp.MustCompile</code>, but because compilation occurs during
initialization, any errors in the regex are exposed immediately on application
startup. Benchmarking the updated function yields significantly better
performance for small strings, but as strings get larger the benefit approaches
zero.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>string length: 130B
BenchmarkCRegex-8  300000  3724 ns/op  880 B/op  16 allocs/op

string length: 130000B
BenchmarkCRegex-8  200  5937989 ns/op  1492260 B/op  10032 allocs/op
</code></pre></td></tr></table></div></div><hr><h2 id=avoiding-regular-expressions>Avoiding Regular Expressions</h2><p>Regular expressions are excellent tools that have many valid uses, but are often
abused when simple text processing will suffice.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>process</span><span class=p>(</span><span class=nx>text</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
	<span class=k>return</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Replace</span><span class=p>(</span><span class=nx>text</span><span class=p>,</span> <span class=s>&#34;hodor&#34;</span><span class=p>,</span> <span class=s>&#34;hold the door&#34;</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>string length: 130B
BenchmarkAvoidRegex-8  2000000  689 ns/op  448 B/op  2 allocs/op

string length: 130000B
BenchmarkAvoidRegex-8  3000  527535 ns/op  425999 B/op  3 allocs/op
</code></pre></td></tr></table></div></div><p>By using <code>strings.Replace</code> instead of a regular expression, we improve the
performance by an order of magnitude for both short and long strings. We also
minimize the number of memory allocations. Keep an eye on the B/op though, it
scales with string size and that may become an issue for very large strings.
Also, what if we want to operate on large files or even a network socket?</p><hr><h2 id=using-ioreader>Using <code>io.Reader</code></h2><p>Let&rsquo;s see if we can make this a bit more generic by using <code>io.Reader</code> instead of
<code>string</code>. We&rsquo;ve seen <code>io.Reader</code> used with things like <code>os.File</code> and figure that we
can make that work somehow. But how do we return the processed data to the
caller? Let&rsquo;s just return another <code>io.Reader</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>process</span><span class=p>(</span><span class=nx>r</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>)</span> <span class=p>(</span><span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>data</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>NewReader</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>Replace</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>data</span><span class=p>),</span> <span class=s>&#34;hodor&#34;</span><span class=p>,</span> <span class=s>&#34;hold the door&#34;</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>)),</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>string length: 130B
BenchmarkBadIface-8  1000000  2111 ns/op  4720 B/op  8 allocs/op

string length: 130000B
BenchmarkBadIface-8  2000  675796 ns/op  1339467 B/op  24 allocs/op
</code></pre></td></tr></table></div></div><p>Great! Now we are using interfaces, we&rsquo;re golden right? Well… not so much. We
aren&rsquo;t using less memory since we are using <code>ioutil.ReadAll</code> (which is almost
always incorrect and only works with readers that return <code>io.EOF</code>). Further, we
are just wastefully turning the result into an <code>io.Reader</code> from the string. To add
insult to injury, our performance has dropped significantly across all metrics
too.</p><hr><h2 id=streaming-data>Streaming Data</h2><p>It now occurs to us that if we streamed the data, byte by byte, we can avoid
the large memory allocations. This does introduce a new knob that will affect
processing performance. We will have to choose how much data to buffer at a
time before running <code>Replace</code>. The larger the chunk size, the higher the B/op.
The smaller the chunk size, the greater the number of times data has to be
copied. There is no right answer for every situation.</p><p>It should be noted that there is a bit of a bug in this implementation in that
the chunk could read until the middle of a <em>hodor</em> and it wouldn&rsquo;t get replaced
properly. Since this code is for demonstration only, fixing it is an exercise
left to the reader.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// DefaultChunkSize is the default amount of data read from an io.Reader
</span><span class=c1></span><span class=kd>const</span> <span class=nx>DefaultChunkSize</span> <span class=p>=</span> <span class=mi>1024</span> <span class=o>*</span> <span class=mi>16</span>

<span class=c1>// Process starts to stream data
</span><span class=c1></span><span class=kd>func</span> <span class=nf>Process</span><span class=p>(</span><span class=nx>r</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>)</span> <span class=p>(</span><span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=kd>var</span> <span class=nx>buf</span><span class=p>,</span> <span class=nx>rbuf</span><span class=p>,</span> <span class=nx>result</span> <span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span>

	<span class=k>for</span> <span class=p>{</span>
		<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>CopyN</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>buf</span><span class=p>,</span> <span class=nx>r</span><span class=p>,</span> <span class=nx>DefaultChunkSize</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>err</span> <span class=o>!=</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
		<span class=p>}</span>

		<span class=k>if</span> <span class=nx>rerr</span> <span class=o>:=</span> <span class=nf>Replace</span><span class=p>(</span><span class=nx>buf</span><span class=p>.</span><span class=nf>Bytes</span><span class=p>(),</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;hodor&#34;</span><span class=p>),</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;hold the door&#34;</span><span class=p>),</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>rbuf</span><span class=p>);</span> <span class=nx>rerr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>rerr</span>
		<span class=p>}</span>

		<span class=nx>buf</span><span class=p>.</span><span class=nf>Reset</span><span class=p>()</span>

		<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>werr</span> <span class=o>:=</span> <span class=nx>result</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>rbuf</span><span class=p>.</span><span class=nf>Bytes</span><span class=p>());</span> <span class=nx>werr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>werr</span>
		<span class=p>}</span>

		<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
			<span class=k>return</span> <span class=o>&amp;</span><span class=nx>result</span><span class=p>,</span> <span class=kc>nil</span>
		<span class=p>}</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>string length: 130B, chunk size: 16384B
BenchmarkBadStream-8  500000  2886 ns/op  4912 B/op  10 allocs/op

string length: 130000B, chunk size: 16384B
BenchmarkBadStream-8  2000  884182 ns/op  1314940 B/op  35 allocs/op
</code></pre></td></tr></table></div></div><p>This is definitely a step in the right direction as we are truly streaming the
data now. However, because we are also managing the output buffer, we still
require more memory and allocations than necessary. Don&rsquo;t worry about the
performance loss, things are about to get much better.</p><hr><h2 id=a-quick-side-note-about-replace>A Quick Side Note about Replace</h2><p>Astute readers will see the as yet undefined <code>Replace</code> in the above code. In
effect, it is only <code>bytes.Replace</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Replace reimplements bytes.Replace in a way that can reuse the buffer
</span><span class=c1></span><span class=kd>func</span> <span class=nf>Replace</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>new</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>buf</span> <span class=o>*</span><span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nx>m</span> <span class=o>:=</span> <span class=mi>0</span>

	<span class=k>if</span> <span class=nx>n</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=c1>// Compute number of replacements.
</span><span class=c1></span>		<span class=nx>m</span> <span class=p>=</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Count</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>old</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>buf</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>buf</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span><span class=p>{}</span>
	<span class=p>}</span>

	<span class=nx>buf</span><span class=p>.</span><span class=nf>Reset</span><span class=p>()</span>

	<span class=k>if</span> <span class=nx>m</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=c1>// Just return a copy.
</span><span class=c1></span>		<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>buf</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
		<span class=k>return</span> <span class=nx>err</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>m</span> <span class=p>&lt;</span> <span class=nx>n</span> <span class=p>{</span>
		<span class=nx>n</span> <span class=p>=</span> <span class=nx>m</span>
	<span class=p>}</span>

	<span class=c1>// Apply replacements to buffer.
</span><span class=c1></span>	<span class=nx>buf</span><span class=p>.</span><span class=nf>Grow</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>+</span> <span class=nx>n</span><span class=o>*</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>new</span><span class=p>)</span><span class=o>-</span><span class=nb>len</span><span class=p>(</span><span class=nx>old</span><span class=p>)))</span>

	<span class=nx>start</span> <span class=o>:=</span> <span class=mi>0</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=nx>j</span> <span class=o>:=</span> <span class=nx>start</span>

		<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>old</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
			<span class=k>if</span> <span class=nx>i</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
				<span class=nx>_</span><span class=p>,</span> <span class=nx>wid</span> <span class=o>:=</span> <span class=nx>utf8</span><span class=p>.</span><span class=nf>DecodeRune</span><span class=p>(</span><span class=nx>s</span><span class=p>[</span><span class=nx>start</span><span class=p>:])</span>
				<span class=nx>j</span> <span class=o>+=</span> <span class=nx>wid</span>
			<span class=p>}</span>
		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
			<span class=nx>j</span> <span class=o>+=</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Index</span><span class=p>(</span><span class=nx>s</span><span class=p>[</span><span class=nx>start</span><span class=p>:],</span> <span class=nx>old</span><span class=p>)</span>
		<span class=p>}</span>

		<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>buf</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>s</span><span class=p>[</span><span class=nx>start</span><span class=p>:</span><span class=nx>j</span><span class=p>]);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>err</span>
		<span class=p>}</span>

		<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>buf</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>new</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>err</span>
		<span class=p>}</span>

		<span class=nx>start</span> <span class=p>=</span> <span class=nx>j</span> <span class=o>+</span> <span class=nb>len</span><span class=p>(</span><span class=nx>old</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>buf</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>s</span><span class=p>[</span><span class=nx>start</span><span class=p>:])</span>
	<span class=k>return</span> <span class=nx>err</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>The difference between <code>Replace</code> and <code>bytes.Replace</code> is that <code>Replace</code> is
passed a <code>bytes.Buffer</code>. The benefit of this is not fully realized yet, but it
allows an already allocated buffer to be used instead of requiring new
allocations every time it is called. This is the same strategy that
<a href=https://golang.org/pkg/io/#CopyBuffer><code>io.CopyBuffer</code></a> uses. Since there is
no <code>bytes.ReplaceBuffer</code> it had to be copied and modified.</p><hr><h2 id=pushing-memory-allocation-to-the-caller>Pushing Memory Allocation to the Caller</h2><p>Let&rsquo;s look at one more possibility for a <code>Process</code> func. Rather than handling the
memory allocation ourselves, with <code>bytes.Buffer</code>, let&rsquo;s let the caller decide how
to handle memory by allowing a passed in <code>io.Writer</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>Process</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>,</span> <span class=nx>r</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=kd>var</span> <span class=nx>buf</span><span class=p>,</span> <span class=nx>rbuf</span> <span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span>
	<span class=k>for</span> <span class=p>{</span>
		<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>CopyN</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>buf</span><span class=p>,</span> <span class=nx>r</span><span class=p>,</span> <span class=nx>DefaultChunkSize</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>err</span> <span class=o>!=</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>err</span>
		<span class=p>}</span>

		<span class=k>if</span> <span class=nx>rerr</span> <span class=o>:=</span> <span class=nf>Replace</span><span class=p>(</span><span class=nx>buf</span><span class=p>.</span><span class=nf>Bytes</span><span class=p>(),</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;hodor&#34;</span><span class=p>),</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;hold the door&#34;</span><span class=p>),</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>rbuf</span><span class=p>);</span> <span class=nx>rerr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>rerr</span>
		<span class=p>}</span>

		<span class=nx>buf</span><span class=p>.</span><span class=nf>Reset</span><span class=p>()</span>

		<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>werr</span> <span class=o>:=</span> <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>rbuf</span><span class=p>.</span><span class=nf>Bytes</span><span class=p>());</span> <span class=nx>werr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>werr</span>
		<span class=p>}</span>

		<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
			<span class=k>return</span> <span class=kc>nil</span>
		<span class=p>}</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>string length: 130B, chunk size: 16384B
BenchmarkMalloc-8  1000000  1897 ns/op  2528 B/op  6 allocs/op

string length: 130000B, chunk size: 16384B
BenchmarkMalloc-8  2000  624815 ns/op  92387 B/op  17 allocs/op
</code></pre></td></tr></table></div></div><p>This is certainly cleaner, and is a bit more performant and memory conscious.
What if there was a way for us to prevent the need for <em>any</em> write buffer?</p><hr><h2 id=implementing-our-own-ioreader>Implementing our own <code>io.Reader</code></h2><p>By writing a <code>Processor</code> that implements the <code>io.Reader</code> interface itself, we can
essentially create a pipeline for data to flow while minimizing data
allocations. As an <code>io.Reader</code> our <code>Processor</code> is usable by any number of packages
in the standard library and third party packages.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Processor implements an io.Reader
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Processor</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>Src</span>       <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span>
	<span class=nx>Old</span><span class=p>,</span> <span class=nx>New</span>  <span class=p>[]</span><span class=kt>byte</span>
	<span class=nx>ChunkSize</span> <span class=kt>int</span>
	<span class=nx>buf</span><span class=p>,</span> <span class=nx>rbuf</span> <span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span>
<span class=p>}</span>

<span class=c1>// Reset the processor
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Processor</span><span class=p>)</span> <span class=nf>Reset</span><span class=p>(</span><span class=nx>src</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>m</span><span class=p>.</span><span class=nx>Src</span> <span class=p>=</span> <span class=nx>src</span>
	<span class=nx>m</span><span class=p>.</span><span class=nx>buf</span><span class=p>.</span><span class=nf>Reset</span><span class=p>()</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Processor</span><span class=p>)</span> <span class=nf>Read</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nx>m</span><span class=p>.</span><span class=nx>ChunkSize</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nx>m</span><span class=p>.</span><span class=nx>ChunkSize</span> <span class=p>=</span> <span class=nx>DefaultChunkSize</span>
	<span class=p>}</span>

	<span class=c1>// first flush any buffered data to p
</span><span class=c1></span>	<span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>buf</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span> <span class=o>||</span> <span class=p>(</span><span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>err</span> <span class=o>!=</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>

	<span class=c1>// m.buf must be empty now
</span><span class=c1></span>	<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>CopyN</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>buf</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Src</span><span class=p>,</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>ChunkSize</span><span class=p>))</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>err</span> <span class=o>!=</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>

	<span class=nx>rerr</span> <span class=o>:=</span> <span class=nf>Replace</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>buf</span><span class=p>.</span><span class=nf>Bytes</span><span class=p>(),</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Old</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>New</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>rbuf</span><span class=p>)</span>
	<span class=nx>m</span><span class=p>.</span><span class=nx>buf</span><span class=p>.</span><span class=nf>Reset</span><span class=p>()</span>

	<span class=k>if</span> <span class=nx>rerr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>rerr</span>
	<span class=p>}</span>

	<span class=nx>copied</span><span class=p>,</span> <span class=nx>rerr</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>rbuf</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>p</span><span class=p>[</span><span class=nx>n</span><span class=p>:])</span>
	<span class=nx>n</span> <span class=o>+=</span> <span class=nx>copied</span>
	<span class=k>if</span> <span class=nx>rerr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>rerr</span> <span class=o>!=</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>rerr</span>
	<span class=p>}</span>

	<span class=c1>// copy anything not put in p, back to the buffer
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rerr</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>buf</span><span class=p>.</span><span class=nf>ReadFrom</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>rbuf</span><span class=p>);</span> <span class=nx>rerr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>rerr</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback># STANDARD CHUNK SIZE

string length: 130B, chunk size: 16384B
BenchmarkProcReadAll-8  2000000   899 ns/op  32 B/op  1 allocs/op
BenchmarkProcRead-8     1000000  1056 ns/op  32 B/op  1 allocs/op

string length: 130000B, chunk size: 16384B
BenchmarkProcReadAll-8   3000  674009 ns/op  256 B/op  8 allocs/op
BenchmarkProcRead-8     30000   54461 ns/op   21 B/op  0 allocs/op

# LARGER CHUNK SIZE

string length: 130B, chunk size: 131072B
BenchmarkProcReadAll-8  2000000  909 ns/op  32 B/op  1 allocs/op
BenchmarkProcRead-8     2000000  985 ns/op  32 B/op  1 allocs/op

string length: 130000B, chunk size: 131072B
BenchmarkProcReadAll-8  2000  642961 ns/op  32 B/op  1 allocs/op
BenchmarkProcRead-8     2000  634125 ns/op  32 B/op  1 allocs/op

# SMALLER CHUNK SIZE

string length: 130B, chunk size: 1024B
BenchmarkProcReadAll-8  2000000  889 ns/op  32 B/op  1 allocs/op
BenchmarkProcRead-8     2000000  910 ns/op  32 B/op  1 allocs/op

string length: 130000B, chunk size: 1024B
BenchmarkProcReadAll-8  2000  623435 ns/op  4065 B/op  127 allocs/op
BenchmarkProcRead-8   500000    3140 ns/op    19 B/op    0 allocs/op
</code></pre></td></tr></table></div></div><p>This is what we were looking for. It is nearly as performant as the
<code>strings.Replace</code> version but uses a fraction of the memory and causes very
little garbage collector thrashing.</p><p>The <code>ReadAll</code> metrics consider reading all of the <code>io.Reader</code> as a single
operation, whereas the <code>Read</code> metrics consider one <code>r.Read</code> function as a single
operation.</p><p>It now becomes much clearer how different chunk sizes affect things. Smaller
chunks result in more allocations, but much faster individual <code>r.Read</code>
operations. Larger chunks work much like <code>strings.Replace</code> since they are getting
most of the data at once and their performance and memory requirements (though
not allocations) approach it as well.</p><p>One thing to note is that the B/op metric is a bit deceiving since we are
reusing the buffers so heavily. They indicate an average across many calls. The
first few calls will do all of the allocations and then all subsequent ones can
reuse them without requiring new allocations. The actual memory used by each
call corresponds more closely with the chunk size.</p><p>For reference, here is the same test as the previous one, but using
<code>bytes.Replace</code> instead of our buffered <code>Replace</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>string length: 130B, chunk size: 16384B
BenchmarkProcReadAll-8 2000000 784 ns/op 256 B/op 2 allocs/op
BenchmarkProcRead-8    2000000 775 ns/op 256 B/op 2 allocs/op

string length: 130000B, chunk size: 16384B
BenchmarkProcReadAll-8  3000 482607 ns/op 224007 B/op 16 allocs/op
BenchmarkProcRead-8    20000  66704 ns/op  28000 B/op  2 allocs/op
</code></pre></td></tr></table></div></div><p>The primary difference is that the B/op metric is 3 orders of magnitude larger
for long strings.</p><p>If you are more of a visual learner, <a href=http://www.charted.co/c/f949a56>here is the data in a few
charts</a>, and <a href="https://docs.google.com/spreadsheets/d/1Ftxpzfe2dgW4wQiysnMp8dyHspUq-IA-NtDTuI-oNtw/edit?usp=sharing">here is its source
data</a>.</p><hr><h2 id=conclusion>Conclusion</h2><p>I&rsquo;ve attempted to illustrate the learning process that someone coming from
languages like Perl or Python might follow. Starting with regular expressions
and ending with implementing an <code>io.Reader</code>, is certainly a possible, if
unlikely, progression. While for this simple example <code>strings.Replace</code> certainly
would have sufficed, more complicated algorithms might justify the additional
complexity.</p><p>Remember, here, as always, write clean, maintainable code first, test it, then
measure its performance. Only then optimize the parts where the performance is
required.</p></article></main></div><div class=footer><div class=footer-links><a href=https://github.com/joshuarubin>GitHub</a>
<a href=https://jawa.dev/posts/index.xml>RSS</a></div><div class=copyright>© 2021 — <a href=https://creativecommons.org/licenses/by/4.0/>Some rights reserved</a></div></div><script>(function(e,b,f,c,a,d){b[c]=b[c]||function(){(b[c].q=b[c].q||[]).push(arguments)},a=e.createElement('script'),d=e.getElementsByTagName('script')[0],a.async=1,a.src=f,a.id='fathom-script',d.parentNode.insertBefore(a,d)})(document,window,'https://fathom.rubixconsulting.com/tracker.js','fathom'),fathom('set','siteId','LLTGF'),fathom('trackPageview')</script></body></html>